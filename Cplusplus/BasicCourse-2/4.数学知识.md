## 4 数学知识

### 4.1 质数

> 质数，又称为素数。是指在大于1的自然数（0,1,2,...）中，除了1和它本身以外不再有其他因数的自然数。

* <font color=red>质数的判定----试除法</font>

  [AcWing 0866. 试除法判定质数](https://www.acwing.com/problem/content/868/)

  ```c++
// 时间复杂度：O(n)
bool is_prime(int n) {
    if (x <= 2) return false;
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;
    return true;
}
  ```

对上面代码进行优化，注意到：如果d可以整除n，即d|n，那么 $\frac{n}{d}|n$，约数是成对出现的。这样我们在枚举约数的时候可以只枚举较小的那一个。

  ```c++
// 时间复杂度：O(sqrt(n))
bool is_prime(int n) {
    if (x <= 2) return false;
    for (int i = 2; i < n / i; i++)
        if (n % i == 0)
            return false;
    return true;
}
  ```

* <font color=red>分解质因数----试除法</font>

[AcWing 0867. 分解质因数](https://www.acwing.com/problem/content/869/)

```c++
// 时间复杂度：O(n)
void divide(int x) {
    for (int i = 2; i <= n; i++)
        if (n % i == 0) {  // 如果该条件成立，则i一定是质数
            int s = 0;
            while (n % i == 0) {
                n /= i;
                s++;
            }
            printf("%d %d\n", i, s);  // 质因数，个数
        }
}
```

对上面代码进行优化，注意到：n中最多包含一个大于sqrt(n)的质因子（可以用反正法证明）

```c++
// 时间复杂度：O(log(n)) ~ O(sqrt(n))
void divide(int x) {
    for (int i = 2; i <= n / i; i++)
        if (n % i == 0) {  // 如果该条件成立，则i一定是质数
            int s = 0;
            while (n % i == 0) {
                n /= i;
                s++;
            }
            printf("%d %d\n", i, s);  // 质因数，个数
        }
    if (n > 1) printf("%d %d\n", n, 1);
}
```

* <font color=red>筛质数</font>

```c++
const int N = 1000010;

int primes[N], cnt;
bool st[N];

// 朴素法筛质数，时间复杂度：O(n*log(n))
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = i + i; j <= n; j += i) st[j] = true;
    }
}
```

对上面代码进行优化，我们只需要将质数的倍数删掉即可

```c++
const int N = 1000010;

int primes[N], cnt;
bool st[N];

// 埃拉托色尼筛选法，时间复杂度：O(n*log(log(n)))
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
        	for (int j = i + i; j <= n; j += i) st[j] = true;
        }
    }
}
```

另外，还存在一个线性筛法

```c++
const int N = 1000010;

int primes[N], cnt;
bool st[N];

// 线性选法，时间复杂度：O(n)
void get_primes(int n) {
    // 核心：每个合数只会被它的最小质因子筛掉
    for (int i = 2; i <= n; i++) {
        if (!st[i]) prime[cnt++] = i;
        // 这里没必要写 j < cnt, 因为i如果为合数的话，枚举到i的最小质因子后一定会停下来
        // 因为i如果为质数的话，枚举到primes[j]后一定会停下来
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
/**
 * primes[j]记为pj，因为从小到大枚举质因子，所以：
 * (1) i % pj == 0 说明：pj是i的最小质因子，pj也是 pj*i的最小质因子
 * (2) i % pj != 0 说明：pj一定小于i的所有质因子，pj也是 pj*i的最小质因子
 * 另外：对于任意一个合数x，都会被筛掉：假设pj是x的最小质因子，当i枚举到
 *      x/pj 的时候，pj已经被枚举过(pj <= x/pj)，x会pj被筛掉
 * --> 因为每个合数都会被筛掉，而且每个数只会被它的最小质因子筛掉，因此每个数
 *     只会被筛一次，时间复杂度是O(n)的
 */
```



































